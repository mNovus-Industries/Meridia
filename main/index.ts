/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-ts-comment */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) MNovus. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
import {
  app,
  BrowserWindow,
  ipcMain,
  dialog,
  Menu,
  autoUpdater,
  MenuItem,
} from "electron";
import fs from "fs";
import Store from "electron-store";
import path from "path";
import { get_file_content, run_code } from "./electron/functions";
import { exec } from "child_process";
import { Pty } from "./electron/pty";
import { IEditorSettings, IUIState } from "../src/shared/types";
import { get_files } from "./electron/get_files";
import { PythonShell } from "python-shell";
import chokidar from "chokidar";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const TOOLS_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export const SELECTED_FOLDER_STORE_NAME = "selected-folder";

export const store = new Store();

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

export let mainWindow: BrowserWindow;
let toolsWindow: BrowserWindow;
let dataStudio: BrowserWindow;
let cwd;

export const MenuTemplate = [
  {
    label: "File",
    submenu: [
      { label: "New Text File" },
      {
        label: "New File",
        accelerator: "Ctrl+N",
        click: () => {
          mainWindow.webContents.send("new-file-tab");
        },
      },
      { type: "separator" },
      {
        label: "Open...",
        accelerator: "Ctrl+O",
        click: async () => {
          // Open the file dialog
          const result = await dialog.showOpenDialog(mainWindow, {
            properties: ["openFile"],
          });

          // Check if the user selected a file
          if (!result.canceled && result.filePaths.length > 0) {
            const filePath = result.filePaths[0];
            const fileName = filePath.split("/").pop(); // Extract file name

            const data = { path: filePath, fileName: fileName };

            // Send file name and full file path to the renderer process
            mainWindow.webContents.send("new-file-opened", data);
          }
        },
      },
      {
        label: "Open Folder...",
        accelerator: "Ctrl+Shift+O",
        click: async () => {
          const folder = await dialog.showOpenDialog(mainWindow, {
            properties: ["openDirectory"],
          });
          let structure: any = undefined;
          if (!folder.canceled) {
            const children = get_files(folder.filePaths[0]);
            structure = {
              id: 1,
              name: folder.filePaths[0],
              root: folder.filePaths[0],
              type: "folder",
              children,
            };

            // @ts-ignore
            store.set(SELECTED_FOLDER_STORE_NAME, structure);
            mainWindow.webContents.send("new-folder-opened");
          }
        },
      },
      { type: "separator" },
      {
        label: "Save",
        click: () => {
          mainWindow.webContents.send("save-current-file");
        },
        accelerator: "Ctrl + S",
      },
      { label: "Save As..." },
      { type: "separator" },
      { type: "separator" },
      { type: "separator" },
      { role: "quit" },
    ],
  },
  {
    label: "Edit",
    submenu: [
      { role: "undo" },
      { role: "redo" },
      { type: "separator" },
      { role: "cut" },
      { role: "copy" },
      { role: "paste" },
      { role: "delete" },
      { type: "separator" },
      { role: "selectAll" },
    ],
  },
  {
    label: "Selection",
    submenu: [
      { role: "selectAll" },
      { label: "Expand Selection" },
      { label: "Shrink Selection" },
      { type: "separator" },
      { label: "Copy Line Up" },
      { label: "Copy Line Down" },
      { label: "Move Line Up" },
      { label: "Move Line Down" },
      { label: "Duplicate Selection" },
      { type: "separator" },
      { label: "Add Cursor Above" },
      { label: "Add Cursor Below" },
      { label: "Add Cursor to Line Ends" },
      { label: "Add Next Occurrence" },
      { label: "Add Previous Occurrence" },
      { label: "Select All Occurrence" },
      { type: "separator" },
      { label: "Column Selection Mode" },
    ],
  },
  {
    label: "View",
    submenu: [
      { label: "Command Palette" },
      { label: "Open View" },
      { type: "separator" },
      {
        label: "Settings",
        accelerator: "Ctrl + ,",
        click: () => {
          mainWindow.webContents.send("open-settings");
        },
      },
      {
        label: "Meridia Studio",
        accelerator: "Ctrl + Shift + B",
        click: () => {
          mainWindow.webContents.send("open-meridia-studio");
        },
      },
      { type: "separator" },
      {
        label: "Sidebar",
        accelerator: "Ctrl + B",
        click: () => {
          mainWindow.webContents.send("open-sidebar");
        },
      },
      {
        label: "Run",
        click: () => {
          mainWindow.webContents.send("run-current-file");
        },
        accelerator: "F12",
      },
      {
        label: "Bottom Panel",
        accelerator: "Ctrl + J",
        click: () => {
          mainWindow.webContents.send("open-bottom-panel");
        },
      },
      {
        label: "Output",
        accelerator: "Ctrl + K",
        click: () => {
          mainWindow.webContents.send("open-output");
        },
      },
      {
        label: "Terminal",
        accelerator: "Ctrl + `",
        click: () => {
          mainWindow.webContents.send("open-terminal");
        },
      },
    ],
  },
  {
    label: "Run",
    submenu: [
      {
        label: "Run",
        click: () => {
          mainWindow.webContents.send("run-code-manual");
        },
        accelerator: "F12",
      },
      { label: "Start Debugging" },
      { label: "Run Without Debugging" },
      { label: "Stop Debugging", enabled: false },
      { label: "Restart Debugging", enabled: false },
      { type: "separator" },
      { label: "Open Configuration", enabled: false },
      { label: "Add Configuration", enabled: true },
      { type: "separator" },
      { label: "Step Over", enabled: false },
      { label: "Step Into", enabled: false },
      { label: "Step Out", enabled: false },
      { label: "Continue", enabled: false },
      { type: "separator" },
      { label: "Toggle Breakpoint" },
      { label: "New Breakpoint" },
      {
        role: "zoom",
        submenu: [
          { role: "resetZoom" },
          { role: "zoomIn" },
          { role: "zoomOut" },
        ],
      },
    ],
  },
] as unknown as MenuItem[];

const menu = Menu.buildFromTemplate(MenuTemplate);
Menu.setApplicationMenu(menu);

export const PUBLIC_FOLDER_PATH = path.join(
  app.getPath("userData"),
  "MeridiaLocalStorage"
);
export const PUBLIC_THEME_FOLDER_PATH = path.join(PUBLIC_FOLDER_PATH, "theme");
export const PUBLIC_STUDIO_FOLDER_PATH = path.join(
  PUBLIC_FOLDER_PATH,
  "studio"
);

export const SETTINGS_JSON_PATH = path.join(
  PUBLIC_FOLDER_PATH,
  "settings.json"
);
export const UI_STATE_JSON_PATH = path.join(
  PUBLIC_FOLDER_PATH,
  "ui_state.json"
);
export const UI_JSON_PATH = path.join(PUBLIC_FOLDER_PATH, "ui.json");
export const MERIDIA_STUDIO_VAR_PATH = path.join(
  PUBLIC_STUDIO_FOLDER_PATH,
  "vars.json"
);

[
  PUBLIC_FOLDER_PATH,
  PUBLIC_THEME_FOLDER_PATH,
  PUBLIC_STUDIO_FOLDER_PATH,
].forEach((folder) => {
  if (!fs.existsSync(folder)) fs.mkdirSync(folder, { recursive: true });
});

[SETTINGS_JSON_PATH, UI_STATE_JSON_PATH, MERIDIA_STUDIO_VAR_PATH].forEach(
  (file) => {
    if (!fs.existsSync(file)) fs.writeFileSync(file, JSON.stringify({}));
  }
);

if (!fs.existsSync(UI_JSON_PATH))
  fs.writeFileSync(UI_JSON_PATH, JSON.stringify({}));

ipcMain.on("clear-settings", () => fs.writeFileSync(SETTINGS_JSON_PATH, "{}"));
ipcMain.on("set-settings", (_, settings: IEditorSettings) =>
  fs.writeFileSync(SETTINGS_JSON_PATH, JSON.stringify(settings))
);

ipcMain.handle("get-settings", async () => {
  try {
    return JSON.parse(fs.readFileSync(SETTINGS_JSON_PATH, "utf-8"));
  } catch (error) {
    return {};
  }
});

ipcMain.on("clear-ui", () => fs.writeFileSync(UI_JSON_PATH, "{}"));
ipcMain.on("set-ui", (_, ui: any) =>
  fs.writeFileSync(UI_JSON_PATH, JSON.stringify(ui))
);

ipcMain.handle("get-ui", async () => {
  try {
    return JSON.parse(fs.readFileSync(UI_JSON_PATH, "utf-8"));
  } catch (error) {
    return {};
  }
});

ipcMain.on("clear-ui-state", () => fs.writeFileSync(UI_STATE_JSON_PATH, "{}"));
ipcMain.on("set-ui-state", (_, state: IUIState) =>
  fs.promises.writeFile(UI_STATE_JSON_PATH, JSON.stringify(state))
);

ipcMain.handle("get-ui-state", async () => {
  try {
    const data = fs.readFileSync(UI_STATE_JSON_PATH, "utf-8");
    return data ? JSON.parse(data) : {};
  } catch (error) {
    return {};
  }
});

ipcMain.handle("get-data-studio-variables", (event) => {
  try {
    const data = fs.readFileSync(MERIDIA_STUDIO_VAR_PATH, "utf-8");
    return data ? JSON.parse(data) : {};
  } catch (error) {
    return {};
  }
});

ipcMain.on("set-data-studio-variables", (event, data) => {
  fs.promises.writeFile(MERIDIA_STUDIO_VAR_PATH, JSON.stringify(data));
});

ipcMain.handle("get-folder", async (event, data) => {
  // @ts-ignore
  return store.get(SELECTED_FOLDER_STORE_NAME);
});

ipcMain.on("clear-folder", () => {
  // @ts-ignore
  store.delete(SELECTED_FOLDER_STORE_NAME);
});

ipcMain.on("create-folder", async (event, data) => {
  fs.mkdirSync(data.path);
});

ipcMain.on("set-folder", (event, folder: string) => {
  set_folder({ folder: folder });
});

ipcMain.handle("open-set-folder", async (event, data) => {
  open_set_folder();
});

ipcMain.on("refresh-window", (event, folder) => {
  refresh_window({ folder });
});

ipcMain.on("create-folder", async (event, data) => {
  create_folder({ data });
});

ipcMain.on("delete-folder", async (event, data) => {
  delete_folder({ data });
});

ipcMain.on("create-file", async (event, data) => {
  create_file({ data });
});

ipcMain.on("delete-file", async (event, data) => {
  delete_file({ data });
});

ipcMain.on(
  "rename",
  (
    event,
    data: {
      newName: string;
      path: string;
      containingFolder: string;
      rootPath: string;
    }
  ) => {
    const node = fs.renameSync(
      data.path,
      path.join(data.containingFolder, data.newName)
    );

    const children = get_files(data.rootPath);
    const structure = {
      id: 1,
      name: data.rootPath,
      root: data.rootPath,
      type: "folder",
      children,
    };

    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, structure);
  }
);

ipcMain.handle("get-file-content", async (event, path) => {
  return get_file_content({ path });
});

ipcMain.handle("run-code", async (event, data) => {
  run_code({ data });
});

ipcMain.on("datavarinfotitle-contextmenu", async (event, data) => {
  const template: any = [
    {
      label: "Copy Name",
      click: () => {},
    },
    { type: "separator" },
    {
      label: "Copy Name",
      click: () => {},
    },
  ];

  const menu = Menu.buildFromTemplate(template);
  menu.popup({ window: BrowserWindow.fromWebContents(event.sender) });
});

ipcMain.on("save-file", async (event, data) => {
  const file_content = fs.writeFileSync(data.path, data.content);
});

ipcMain.on("send-tools-data", (event, data) => {
  mainWindow.webContents.send("update-tools-data", data);
});

ipcMain.handle("install-package", async (_, packageName: string) => {
  return new Promise((resolve) => {
    exec(`pip install ${packageName}`, (error, stdout, stderr) => {
      resolve(error ? stderr : stdout);
    });
  });
});

ipcMain.handle("uninstall-package", async (_, packageName: string) => {
  return new Promise((resolve) => {
    exec(`pip uninstall -y ${packageName}`, (error, stdout, stderr) => {
      resolve(error ? stderr : stdout);
    });
  });
});

ipcMain.handle("get-installed-packages", async () => {
  return new Promise((resolve) => {
    exec("pip list --format=json", (error, stdout, stderr) => {
      if (error) {
        resolve([]);
      } else {
        try {
          resolve(JSON.parse(stdout));
        } catch (e) {
          resolve([]);
        }
      }
    });
  });
});

// Fetch available packages from PyPI
ipcMain.handle("search-pypi-packages", async (_, query: string) => {
  try {
    const response = await fetch(`https://pypi.org/pypi/${query}/json`);
    if (!response.ok) throw new Error("Package not found");
    const data = await response.json();
    return {
      name: data.info.name,
      version: data.info.version,
      summary: data.info.summary,
    };
  } catch (error) {
    return null;
  }
});

ipcMain.handle("run-python-code", async (_, code: string) => {
  return new Promise((resolve) => {
    if (!code || typeof code !== "string") {
      resolve({}); // Return an empty object instead of failing
      return;
    }

    let outputMap: Record<string, string> = {};

    try {
      let pyshell = new PythonShell(PythonShell.defaultPythonPath, {
        mode: "text",
      });

      pyshell.send(code);

      pyshell.on("message", (message) => {
        if (!message) return;

        const printedLines = message.split("\n");
        let lines = code.split("\n");
        let printIndex = 0;

        lines.forEach((line, index) => {
          if (
            line.trim().startsWith("print(") &&
            printIndex < printedLines.length
          ) {
            outputMap[index + 1] = printedLines[printIndex++] || "..."; // Ensure value
          }
        });
      });

      pyshell.end(() => {
        resolve(outputMap);
      });
    } catch (error) {
      resolve({}); // Prevent undefined errors
    }
  });
});

export const open_set_folder = async () => {
  const folder = await dialog.showOpenDialog(mainWindow, {
    properties: ["openDirectory"],
  });
  let structure = undefined;
  if (!folder.canceled) {
    const children = get_files(folder.filePaths[0]);
    structure = {
      // name: path.dirname(folder.filePaths[0]),
      id: 0,
      name: folder.filePaths[0],
      root: folder.filePaths[0],
      type: "folder",
      children,
    };
    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, structure);
    // ipcMain.emit('new-folder-opened')
    mainWindow.webContents.send("new-folder-opened");
  }
};

export const open_folder = async () => {
  const folder = await dialog.showOpenDialog(mainWindow, {
    properties: ["openDirectory"],
  });
  let structure = undefined;
  if (!folder.canceled) {
    const children = get_files(folder.filePaths[0]);
    structure = {
      id: 1,
      name: folder.filePaths[0],
      root: folder.filePaths[0],
      type: "folder",
      children,
    };
    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, structure);
  }

  return structure;
};

export const delete_file = ({
  data,
}: {
  data: { path: string; rootPath: string };
}) => {
  if (!path) return;
  const folder = fs.rmSync(data.path);

  const children = get_files(data.rootPath);
  const structure = {
    id: 1,
    name: data.rootPath,
    root: data.rootPath,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);
};

export const delete_folder = ({
  data,
}: {
  data: { path: string; rootPath: string };
}) => {
  if (!data.path) return;

  // Delete folder and contents recursively
  fs.rmSync(data.path, { recursive: true, force: true });

  // Rebuild file structure
  const children = get_files(data.rootPath);
  const structure = {
    id: 1,
    name: data.rootPath,
    root: data.rootPath,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);
};

export const set_folder = ({ folder }: { folder: string }) => {
  let structure = undefined;

  try {
    const children = get_files(folder);
    structure = {
      id: 1,
      name: folder,
      root: folder,
      type: "folder",
      children,
    };

    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, structure);

    mainWindow.webContents.send("new-folder-opened", structure);
  } catch (error) {
    mainWindow.webContents.send("error-opening-folder", error.message);
  }
};

export const refresh_window = ({ folder }: { folder: string }) => {
  let structure = undefined;

  const children = get_files(folder);
  structure = {
    id: 0,
    name: folder,
    root: folder,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);
  mainWindow.webContents.send("new-folder-opened");
};

export const create_folder = ({
  data,
}: {
  data: { path: string; rootPath: string; fileName: string };
}) => {
  const new_folder = fs.mkdirSync(path.join(data.path, data.fileName));

  const children = get_files(data.rootPath);
  const structure = {
    id: 1,
    name: data.rootPath,
    root: data.rootPath,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);

  const newFolder = {
    name: data.fileName,
    parentPath: data.path,
    path: data.path,
    is_dir: true,
  };
};

export const create_file = ({
  data,
}: {
  data: { path: string; rootPath: string; fileName: string };
}) => {
  const new_file = fs.writeFileSync(path.join(data.path, data.fileName), "");

  const children = get_files(data.rootPath);
  const structure = {
    id: 1,
    name: data.rootPath,
    root: data.rootPath,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);
};

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    frame: false,
    title: "Meridia",
    icon: path.join(__dirname, "..", "..", "src", "assets/icon.ico"),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      // nodeIntegration: true,
    },
    // zoomToPageWidth: true,
  });

  mainWindow.on("close", () => {
    mainWindow.webContents.send("handle-window-closing");
  });
  ipcMain.handle("minimize", () => {
    mainWindow.minimize();
  });

  ipcMain.handle("close", () => {
    mainWindow.close();
  });

  ipcMain.handle("maximize", () => {
    mainWindow.maximize();
  });

  ipcMain.handle("restore", () => {
    mainWindow.restore();
  });

  mainWindow.on("maximize", () => {
    mainWindow.webContents.send("window-changed-to-maximized");
  });

  mainWindow.on("unmaximize", () => {
    mainWindow.webContents.send("window-changed-to-restore");
  });

  ipcMain.handle("get-menu", () => {
    const menu = Menu.getApplicationMenu();
    return menu?.items.map((item, index) => ({
      id: `menu-${index}`,
      label: item.label,
      accelerator: item.accelerator || item.role || "",
      type: item.type || "",
      submenu: item.submenu?.items.map((sub, subIndex) => ({
        id: `menu-${index}-sub-${subIndex}`,
        label: sub.label,
        accelerator: sub.accelerator || "",
      })),
    }));
  });

  ipcMain.on("menu-click", (event, menuId) => {
    const menu = Menu.getApplicationMenu();
    if (!menu) return;

    menu.items.forEach((item, index) => {
      if (`menu-${index}` === menuId && item.click) {
        item.click(); // Execute the menu click function
      }
      if (item.submenu) {
        item.submenu.items.forEach((sub, subIndex) => {
          if (`menu-${index}-sub-${subIndex}` === menuId && sub.click) {
            sub.click();
          }
        });
      }
    });
  });

  mainWindow.maximize();

  // @ts-ignore
  store.get(SELECTED_FOLDER_STORE_NAME);

  try {
    // @ts-ignore
    cwd = store.get(SELECTED_FOLDER_STORE_NAME).root;
  } catch {
    cwd = "/";
  }

  const watcher = chokidar.watch(cwd, {
    persistent: true,
    ignoreInitial: false,
  });

  const recentRemovals = new Map<string, NodeJS.Timeout>();

  watcher
    .on("add", (filePath: string) => {
      console.log(`ðŸ“„ File added: ${filePath}`);
      const containingFolder = path.dirname(filePath); // Get directory path
      const fileName = path.basename(filePath); // Get file name

      console.log(`ðŸ“„ File added: ${filePath}`);
      console.log(`ðŸ“‚ Containing Folder: ${containingFolder}`);
      console.log(`ðŸ“ File Name: ${fileName}`);

      mainWindow.webContents.send("new-file-created", {
        fullPath: filePath,
        containingFolder,
        fileName,
      });
    })
    .on("change", (filePath) => {
      console.log(`âœï¸ File changed: ${filePath}`);
      mainWindow.webContents.send("new-file-change", filePath);
    })
    .on("unlink", (filePath) => {
      console.log(`ðŸ—‘ï¸ File removed (checking for rename): ${filePath}`);

      // Store the removed file temporarily to detect renames
      const timeout = setTimeout(() => {
        console.log(`âŒ File permanently removed: ${filePath}`);
        mainWindow.webContents.send("file-removed", filePath);
        recentRemovals.delete(filePath);
      }, 100);

      recentRemovals.set(filePath, timeout);
    })
    .on("addDir", (folderPath) => {
      console.log(`ðŸ“ Folder added: ${folderPath}`);
      mainWindow.webContents.send("new-folder-created", folderPath);
    })
    .on("unlinkDir", (folderPath) => {
      console.log(`ðŸ“‚ Folder removed: ${folderPath}`);
      mainWindow.webContents.send("folder-removed", folderPath);
    })
    .on("error", (error) => console.log(`ðŸš¨ Watcher error: ${error}`));

  // Rename detection
  watcher.on("add", (newPath) => {
    for (const [oldPath, timeout] of recentRemovals.entries()) {
      if (path.dirname(oldPath) === path.dirname(newPath)) {
        clearTimeout(timeout);
        recentRemovals.delete(oldPath);
        console.log(`ðŸ”„ File/Folder renamed: ${oldPath} â†’ ${newPath}`);
        mainWindow.webContents.send("file-folder-renamed", {
          oldPath,
          newPath,
        });
        return;
      }
    }
  });

  Pty({ cwd: cwd, ipcMain: ipcMain });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  ipcMain.handle("open-folder", async (event, data) => {
    open_folder();
  });

  mainWindow.once("ready-to-show", () => {
    // Open the DevTools.
    mainWindow.webContents.openDevTools();
    mainWindow.show(); // Show the main window
  });
};

const createToolsWindow = () => {
  if (!toolsWindow) {
    toolsWindow = new BrowserWindow({
      height: 800,
      width: 1200,
      show: false,
      icon: path.join(__dirname, "src", "assets", "icon.ico"),
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        // nodeIntegration: true,
      },
    });

    toolsWindow.loadURL(TOOLS_WINDOW_WEBPACK_ENTRY);

    toolsWindow.setMenuBarVisibility(false);

    toolsWindow.on("closed", () => {
      toolsWindow = null;
      mainWindow.webContents.send("tools-window-closed");
    });
  }
};

ipcMain.handle("show-tools", () => {
  createToolsWindow();

  if (toolsWindow && toolsWindow.isMinimized()) {
    toolsWindow.restore();
  }

  toolsWindow?.show();
});

ipcMain.handle("hide-tools", () => {
  if (toolsWindow) {
    toolsWindow.hide();
  }
});

const createDataStudioWindow = () => {
  if (!dataStudio) {
    dataStudio = new BrowserWindow({
      height: 800,
      width: 1200,
      show: false,
      frame: false,

      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        // nodeIntegration: true,
      },
    });

    dataStudio.loadFile("./src/dataStudio.html");

    dataStudio.setMenuBarVisibility(false);

    dataStudio.on("closed", () => {
      dataStudio = null;
      mainWindow.webContents.send("datastudio-window-closed");
    });
  }
};

ipcMain.handle("show-datastudio", () => {
  createDataStudioWindow();

  if (dataStudio && dataStudio.isMinimized()) {
    dataStudio.restore();
  }

  dataStudio?.show();
});

ipcMain.handle("hide-datastudio", () => {
  if (dataStudio) {
    dataStudio.hide();
  }
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  createWindow();
  createToolsWindow();

  // Check for updates on startup
  autoUpdater.checkForUpdates();

  autoUpdater.on("update-available", () => {
    dialog.showMessageBox({
      type: "info",
      title: "Update Available",
      message:
        "A new version of the Anantam is available. The update will be downloaded and installed automatically.",
    });
  });

  autoUpdater.on("update-downloaded", () => {
    dialog
      .showMessageBox({
        type: "question",
        title: "Update Ready",
        message:
          "The update has been downloaded. Do you want to restart Anantam now to apply the update?",
        buttons: ["Restart Now", "Later"],
        defaultId: 0,
        cancelId: 1,
      })
      .then((result) => {
        if (result.response === 0) {
          autoUpdater.quitAndInstall();
        } else {
        }
      });
  });

  autoUpdater.on("error", (error) => {});
});
// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
