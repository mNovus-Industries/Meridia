/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable @typescript-eslint/ban-ts-comment */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) MNovus. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// Import
import {
  app,
  BrowserWindow,
  ipcMain,
  dialog,
  Menu,
  autoUpdater,
  MenuItem,
} from "electron";

// FileSytem
import fs from "fs";

// Store for local storage
import Store from "electron-store";

import path from "path";

import { get_file_content, run_code } from "./electron/functions";

import { exec } from "child_process";

import { Pty } from "./electron/pty";

import { IEditorSettings, IUI, IUIState } from "../src/shared/types";

import { get_files } from "./electron/get_files";
import { PythonShell } from "python-shell";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const TOOLS_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

export const SELECTED_FOLDER_STORE_NAME = "selected-folder";

export const store = new Store();

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

export let mainWindow: BrowserWindow;
let toolsWindow: BrowserWindow;
let dataStudio: BrowserWindow;
let cwd;

export const MenuTemplate = [
  {
    label: "File",
    submenu: [
      { label: "New Text File" },
      {
        label: "New File",
        accelerator: "Ctrl+N",
        click: () => {
          mainWindow.webContents.send("new-file-tab");
        },
      },
      { label: "New Window" },
      { type: "separator" },
      {
        label: "Open...",
        accelerator: "Ctrl+O",
        click: async () => {
          // Open the file dialog
          const result = await dialog.showOpenDialog(mainWindow, {
            properties: ["openFile"],
          });

          // Check if the user selected a file
          if (!result.canceled && result.filePaths.length > 0) {
            const filePath = result.filePaths[0];
            const fileName = filePath.split("/").pop(); // Extract file name

            // Send file name and full file path to the renderer process
            mainWindow.webContents.send("new-file-opened", {
              fileName,
              filePath,
            });
          }
        },
      },
      {
        label: "Open Folder...",
        click: async () => {
          const folder = await dialog.showOpenDialog(mainWindow, {
            properties: ["openDirectory"],
          });
          let structure: any = undefined;
          if (!folder.canceled) {
            console.log("folder", folder.filePaths[0]);
            const children = get_files(folder.filePaths[0]);
            structure = {
              id: 1,
              name: folder.filePaths[0],
              root: folder.filePaths[0],
              type: "folder",
              children,
            };

            // @ts-ignore
            store.set(SELECTED_FOLDER_STORE_NAME, structure);
            mainWindow.webContents.send("new-folder-opened");
          }
        },
      },
      { label: "Open Workspace From File..." },
      { label: "Open Recent", submenu: [{ label: "Recent File" }] },
      { type: "separator" },
      { label: "Add Folder to Workspace" },
      { label: "Save Workspace As" },
      { label: "Duplicate Workspace" },
      { type: "separator" },
      {
        label: "Save",
        click: () => {
          mainWindow.webContents.send("save-current-file");
        },
        accelerator: "Ctrl + S",
      },
      { label: "Save As..." },
      { label: "Save All" },
      { type: "separator" },
      { type: "separator" },
      { label: "Autosave", type: "checkbox", checked: true },
      { type: "separator" },
      { label: "Close Editor", role: "quit" },
      { label: "Close Folder", role: "quit" },
      { role: "quit" },
    ],
  },
  {
    label: "Edit",
    submenu: [
      { role: "undo" },
      { role: "redo" },
      { type: "separator" },
      { role: "cut" },
      { role: "copy" },
      { role: "paste" },
      { role: "delete" },
      { type: "separator" },
      { role: "selectAll" },
    ],
  },
  {
    label: "Selection",
    submenu: [
      { role: "selectAll" },
      { label: "Expand Selection" },
      { label: "Shrink Selection" },
      { type: "separator" },
      { label: "Copy Line Up" },
      { label: "Copy Line Down" },
      { label: "Move Line Up" },
      { label: "Move Line Down" },
      { label: "Duplicate Selection" },
      { type: "separator" },
      { label: "Add Cursor Above" },
      { label: "Add Cursor Below" },
      { label: "Add Cursor to Line Ends" },
      { label: "Add Next Occurrence" },
      { label: "Add Previous Occurrence" },
      { label: "Select All Occurrence" },
      { type: "separator" },
      { label: "Column Selection Mode" },
    ],
  },
  {
    label: "View",
    submenu: [
      { label: "Command Palette" },
      { label: "Open View" },
      { type: "separator" },
      {
        label: "Settings",
        accelerator: "Ctrl + ,",
        click: () => {
          mainWindow.webContents.send("open-settings");
        },
      },
      {
        label: "Meridia Studio",
        accelerator: "Ctrl + Shift + B",
        click: () => {
          mainWindow.webContents.send("open-meridia-studio");
        },
      },
      { type: "separator" },
      {
        label: "Sidebar",
        accelerator: "Ctrl + B",
        click: () => {
          mainWindow.webContents.send("open-sidebar");
        },
      },
      {
        label: "Run",
        click: () => {
          mainWindow.webContents.send("run-current-file");
        },
        accelerator: "F12",
      },
      {
        label: "Bottom Panel",
        accelerator: "Ctrl + J",
        click: () => {
          mainWindow.webContents.send("open-bottom-panel");
        },
      },
      {
        label: "Output",
        accelerator: "Ctrl + K",
        click: () => {
          mainWindow.webContents.send("open-output");
        },
      },
      {
        label: "Terminal",
        accelerator: "Ctrl + `",
        click: () => {
          mainWindow.webContents.send("open-terminal");
        },
      },
      { type: "separator" },
      { label: "Word Wrap" },
    ],
  },
  {
    label: "Go",
    submenu: [
      { label: "Back" },
      { label: "Forward", enabled: false },
      { label: "Last Edit Location" },
      {
        label: "Switch Editor",
        submenu: [
          { label: "Next Editor" },
          { label: "Previous Editor" },
          { type: "separator" },
          { label: "Next Used Editor" },
          { label: "Previous Used Editor" },
          { type: "separator" },
          { label: "Next Editor in Group" },
          { label: "Previous Editor in Group" },
        ],
      },
      {
        label: "Switch Group",
        submenu: [
          { label: "Group 1" },
          { label: "Group 2" },
          { label: "Group 3", enabled: false },
          { label: "Group 4", enabled: false },
          { type: "separator" },
          { label: "Next Group", enabled: false },
          { label: "Previous Group", enabled: false },
        ],
      },
      { type: "separator" },
      { label: "Go to File" },
      { label: "Go to Symbol in Workspace" },
      { type: "separator" },
      { label: "Go to Symbol in Editor" },
      { label: "Go to Definition" },
      { label: "Go to Declaration" },
      { label: "Go to Type Definition" },
      { label: "Go to Implementations" },
      { label: "Go to References" },
      { type: "separator" },
      { label: "Go to Line/Column" },
      { label: "Go to Bracket" },
      { type: "separator" },
      { label: "Next Problem" },
      { label: "Previous Problem" },
      { type: "separator" },
      { label: "Next Change" },
      { label: "Previous Change" },
    ],
  },
  {
    label: "Run",
    submenu: [
      {
        label: "Run",
        click: () => {
          mainWindow.webContents.send("run-code-manual");
        },
        accelerator: "F12",
      },
      { label: "Start Debugging" },
      { label: "Run Without Debugging" },
      { label: "Stop Debugging", enabled: false },
      { label: "Restart Debugging", enabled: false },
      { type: "separator" },
      { label: "Open Configuration", enabled: false },
      { label: "Add Configuration", enabled: true },
      { type: "separator" },
      { label: "Step Over", enabled: false },
      { label: "Step Into", enabled: false },
      { label: "Step Out", enabled: false },
      { label: "Continue", enabled: false },
      { type: "separator" },
      { label: "Toggle Breakpoint" },
      { label: "New Breakpoint" },
      {
        role: "zoom",
        submenu: [
          { role: "resetZoom" },
          { role: "zoomIn" },
          { role: "zoomOut" },
        ],
      },
    ],
  },
] as unknown as MenuItem[];

const menu = Menu.buildFromTemplate(MenuTemplate);
Menu.setApplicationMenu(menu);
export const PUBLIC_FOLDER_PATH = path.join(
  app.getPath("userData"),
  "MeridiaLocalStorage"
);
export const PUBLIC_THEME_FOLDER_PATH = path.join(PUBLIC_FOLDER_PATH, "theme");

export const SETTINGS_JSON_PATH = path.join(
  PUBLIC_FOLDER_PATH,
  "settings.json"
);
export const UI_STATE_JSON_PATH = path.join(
  PUBLIC_FOLDER_PATH,
  "ui_state.json"
);
export const UI_JSON_PATH = path.join(PUBLIC_FOLDER_PATH, "ui.json");

[PUBLIC_FOLDER_PATH, PUBLIC_THEME_FOLDER_PATH].forEach((folder) => {
  if (!fs.existsSync(folder)) fs.mkdirSync(folder, { recursive: true });
});

[SETTINGS_JSON_PATH, UI_STATE_JSON_PATH].forEach((file) => {
  if (!fs.existsSync(file)) fs.writeFileSync(file, JSON.stringify({}));
});

if (!fs.existsSync(UI_JSON_PATH))
  fs.writeFileSync(
    UI_JSON_PATH,
    JSON.stringify({
      header: [
        {
          name: "Run",
          type: "run-file",
          tooltip: "Run",
          shortcut: "F12",
        },
      ],
      sidebar: [
        {
          name: "Navigator",
          position: "top",
          tooltip: "Navigator",
          shortcut: "",
          content: "content",
        },
        {
          name: "Settings",
          position: "bottom",
          tooltip: "Settings",
          shortcut: "Ctrl + ,",
          content: "settings",
        },
        {
          name: "Meridia Studio",
          position: "bottom",
          tooltip: "MStudio",
          shortcut: "Ctrl + Shift + B",
          content: "mstudio",
        },
      ],
      footer: [
        {
          name: "Project Name",
          type: "project-name",
          text: "[project-name]",
          tooltip: "[project-name]",
        },
        {
          name: "Language",
          type: "selected-file-language",
          text: "[file-language]",
          tooltip: "[file-language]",
        },
        {
          name: "Indent",
          type: "editor-indent",
          text: "[editor-indent]",
          tooltip: "[editor-indent]",
        },
        {
          name: "Spaces",
          type: "editor-spaces",
          text: "[editor-spaces]",
          tooltip: "[editor-spaces]",
        },
        {
          name: "UTF",
          type: "editor-utf",
          text: "[editor-utf]",
          tooltip: "[editor-utf]",
        },
        {
          name: "AI",
          type: "extensions",
          text: "[extensions-footer-items-text]",
          tooltip: "[extensions-footer-items-tooltip]",
        },
      ],
    })
  );

ipcMain.on("clear-settings", () => fs.writeFileSync(SETTINGS_JSON_PATH, "{}"));
ipcMain.on("set-settings", (_, settings: IEditorSettings) =>
  fs.writeFileSync(SETTINGS_JSON_PATH, JSON.stringify(settings))
);

ipcMain.handle("get-settings", async () => {
  try {
    return JSON.parse(fs.readFileSync(SETTINGS_JSON_PATH, "utf-8"));
  } catch (error) {
    console.error("Failed to read settings:", error);
    return {};
  }
});

ipcMain.on("clear-ui", () => fs.writeFileSync(UI_JSON_PATH, "{}"));
ipcMain.on("set-ui", (_, ui: any) =>
  fs.writeFileSync(UI_JSON_PATH, JSON.stringify(ui))
);

ipcMain.handle("get-ui", async () => {
  try {
    return JSON.parse(fs.readFileSync(UI_JSON_PATH, "utf-8"));
  } catch (error) {
    console.error("Failed to read settings:", error);
    return {};
  }
});

ipcMain.on("clear-ui-state", () => fs.writeFileSync(UI_STATE_JSON_PATH, "{}"));
ipcMain.on("set-ui-state", (_, state: IUIState) =>
  fs.promises.writeFile(UI_STATE_JSON_PATH, JSON.stringify(state))
);

ipcMain.handle("get-ui-state", async () => {
  try {
    const data = fs.readFileSync(UI_STATE_JSON_PATH, "utf-8");
    return data ? JSON.parse(data) : {};
  } catch (error) {
    console.error("Failed to read UI state:", error);
    return {};
  }
});

ipcMain.handle("get-folder", async (event, data) => {
  // @ts-ignore
  return store.get(SELECTED_FOLDER_STORE_NAME);
});

ipcMain.on("clear-folder", () => {
  // @ts-ignore
  store.delete(SELECTED_FOLDER_STORE_NAME);
});

ipcMain.on("create-folder", async (event, data) => {
  fs.mkdirSync(data.path);
});

ipcMain.on("set-folder", (event, folder: string) => {
  set_folder({ folder: folder });
});

ipcMain.handle("open-set-folder", async (event, data) => {
  open_set_folder();
});

ipcMain.on("refresh-window", (event, folder) => {
  refresh_window({ folder });
});

ipcMain.on("create-folder", async (event, data) => {
  create_folder({ data });
});

ipcMain.on("create-file", async (event, data) => {
  create_file({ data });
});

ipcMain.handle("get-file-content", async (event, path) => {
  return get_file_content({ path });
});

ipcMain.handle("run-code", async (event, data) => {
  run_code({ data });
});

ipcMain.handle("get-data-studio-variables", (event) => {
  // @ts-ignore
  return store.get(DATASTUDIO_VARIABLES_STORE_NAME);
});

ipcMain.on("set-data-studio-variables", (event, data) => {
  // @ts-ignore
  return store.set(DATASTUDIO_VARIABLES_STORE_NAME, data);
});

ipcMain.on("new-folder-input", (event, data) => {
  event.sender.send("command-create-folder", data);
});
ipcMain.on("new-file-input", (event, data) => {
  event.sender.send("command-create-file", data);
});

ipcMain.on("folder-contextmenu", async (event, data) => {
  const template: any = [
    {
      label: "New File...",
      click: () => {
        event.sender.send("command-create-file", data);
      },
      visible: data.type == "folder",
    },
    {
      label: "New Folder...",
      click: () => {
        event.sender.send("command-create-folder", data);
      },
      visible: data.type == "folder",
    },
    { type: "separator" },
    {
      label: "Cut",
      role: "cut",

      enabled: true,
    },
    {
      label: "Copy",
      role: "copy",

      enabled: true,
    },
    {
      label: "Paste",
      role: "paste",
    },
    {
      label: "Copy Relative Path",
    },
    { type: "separator" },
    {
      label: "Rename",
      role: "editMenu",
    },
    {
      label: "Delete",
    },
  ];

  const menu = Menu.buildFromTemplate(template);
  menu.popup({ window: BrowserWindow.fromWebContents(event.sender) });
});

ipcMain.on("datavarinfotitle-contextmenu", async (event, data) => {
  const template: any = [
    {
      label: "Copy Name",
      click: () => {},
    },
    { type: "separator" },
    {
      label: "Copy Name",
      click: () => {},
    },
  ];

  const menu = Menu.buildFromTemplate(template);
  menu.popup({ window: BrowserWindow.fromWebContents(event.sender) });
});

ipcMain.on("save-file", async (event, data) => {
  const file_content = fs.writeFileSync(data.path, data.content);
  console.log("file writen");
});

ipcMain.on("send-tools-data", (event, data) => {
  mainWindow.webContents.send("update-tools-data", data);
});

ipcMain.handle("install-package", async (_, packageName: string) => {
  return new Promise((resolve) => {
    exec(`pip install ${packageName}`, (error, stdout, stderr) => {
      resolve(error ? stderr : stdout);
    });
  });
});

ipcMain.handle("uninstall-package", async (_, packageName: string) => {
  return new Promise((resolve) => {
    exec(`pip uninstall -y ${packageName}`, (error, stdout, stderr) => {
      resolve(error ? stderr : stdout);
    });
  });
});

ipcMain.handle("get-installed-packages", async () => {
  return new Promise((resolve) => {
    exec("pip list --format=json", (error, stdout, stderr) => {
      if (error) {
        resolve([]);
      } else {
        try {
          resolve(JSON.parse(stdout));
        } catch (e) {
          resolve([]);
        }
      }
    });
  });
});

// Fetch available packages from PyPI
ipcMain.handle("search-pypi-packages", async (_, query: string) => {
  try {
    const response = await fetch(`https://pypi.org/pypi/${query}/json`);
    if (!response.ok) throw new Error("Package not found");
    const data = await response.json();
    return {
      name: data.info.name,
      version: data.info.version,
      summary: data.info.summary,
    };
  } catch (error) {
    return null;
  }
});

ipcMain.handle("run-python-code", async (_, code: string) => {
  return new Promise((resolve) => {
    if (!code || typeof code !== "string") {
      console.error("Invalid code received:", code);
      resolve({}); // Return an empty object instead of failing
      return;
    }

    let outputMap: Record<string, string> = {};

    try {
      let pyshell = new PythonShell(PythonShell.defaultPythonPath, {
        mode: "text",
      });

      pyshell.send(code);

      pyshell.on("message", (message) => {
        if (!message) return;

        const printedLines = message.split("\n");
        let lines = code.split("\n");
        let printIndex = 0;

        lines.forEach((line, index) => {
          if (
            line.trim().startsWith("print(") &&
            printIndex < printedLines.length
          ) {
            outputMap[index + 1] = printedLines[printIndex++] || "..."; // Ensure value
          }
        });
      });

      pyshell.end(() => {
        resolve(outputMap);
      });
    } catch (error) {
      console.error("Python execution failed:", error);
      resolve({}); // Prevent undefined errors
    }
  });
});

export const open_set_folder = async () => {
  const folder = await dialog.showOpenDialog(mainWindow, {
    properties: ["openDirectory"],
  });
  let structure = undefined;
  if (!folder.canceled) {
    console.log("folder", folder.filePaths[0]);
    const children = get_files(folder.filePaths[0]);
    structure = {
      // name: path.dirname(folder.filePaths[0]),
      id: 0,
      name: folder.filePaths[0],
      root: folder.filePaths[0],
      type: "folder",
      children,
    };
    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, structure);
    // ipcMain.emit('new-folder-opened')
    mainWindow.webContents.send("new-folder-opened");
  }
};

export const open_folder = async () => {
  const folder = await dialog.showOpenDialog(mainWindow, {
    properties: ["openDirectory"],
  });
  let structure = undefined;
  if (!folder.canceled) {
    const children = get_files(folder.filePaths[0]);
    structure = {
      id: 1,
      name: folder.filePaths[0],
      root: folder.filePaths[0],
      type: "folder",
      children,
    };
    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, structure);
  }

  return structure;
};

export const set_folder = ({ folder }: { folder: string }) => {
  let structure = undefined;

  try {
    const children = get_files(folder);
    structure = {
      id: 1,
      name: folder,
      root: folder,
      type: "folder",
      children,
    };

    // @ts-ignore
    store.set(SELECTED_FOLDER_STORE_NAME, structure);

    mainWindow.webContents.send("new-folder-opened", structure);
  } catch (error) {
    console.error(`Error while reading the folder: ${error.message}`);
    mainWindow.webContents.send("error-opening-folder", error.message);
  }
};

export const refresh_window = ({ folder }: { folder: string }) => {
  let structure = undefined;

  const children = get_files(folder);
  structure = {
    id: 0,
    name: folder,
    root: folder,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);
  mainWindow.webContents.send("new-folder-opened");
};

export const create_folder = ({
  data,
}: {
  data: { path: string; rootPath: string; fileName: string };
}) => {
  const new_folder = fs.mkdirSync(path.join(data.path, data.fileName));

  const children = get_files(data.rootPath);
  const structure = {
    // name: path.dirname(data.rootPath),
    id: 1,
    name: data.rootPath,
    root: data.rootPath,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);

  const newFolder = {
    name: data.fileName,
    parentPath: data.path,
    path: data.path,
    is_dir: true,
  };
};

export const create_file = ({
  data,
}: {
  data: { path: string; rootPath: string; fileName: string };
}) => {
  const new_file = fs.writeFileSync(path.join(data.path, data.fileName), "");

  const children = get_files(data.rootPath);
  const structure = {
    id: 1,
    name: data.rootPath,
    root: data.rootPath,
    type: "folder",
    children,
  };

  // @ts-ignore
  store.set(SELECTED_FOLDER_STORE_NAME, structure);
};

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 600,
    width: 800,
    frame: false,
    title: "Meridia",
    icon: path.join(__dirname, "..", "..", "src", "assets/icon.ico"),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      // nodeIntegration: true,
    },
    // zoomToPageWidth: true,
  });

  mainWindow.on("close", () => {
    mainWindow.webContents.send("handle-window-closing");
  });
  ipcMain.handle("minimize", () => {
    mainWindow.minimize();
  });

  ipcMain.handle("close", () => {
    mainWindow.close();
  });

  ipcMain.handle("maximize", () => {
    mainWindow.maximize();
  });

  ipcMain.handle("restore", () => {
    mainWindow.restore();
  });

  mainWindow.on("maximize", () => {
    mainWindow.webContents.send("window-changed-to-maximized");
  });

  mainWindow.on("unmaximize", () => {
    mainWindow.webContents.send("window-changed-to-restore");
  });

  ipcMain.handle("get-menu", () => {
    const menu = Menu.getApplicationMenu();
    return menu?.items.map((item, index) => ({
      id: `menu-${index}`,
      label: item.label,
      accelerator: item.accelerator || item.role || "",
      type: item.type || "",
      submenu: item.submenu?.items.map((sub, subIndex) => ({
        id: `menu-${index}-sub-${subIndex}`,
        label: sub.label,
        accelerator: sub.accelerator || "",
      })),
    }));
  });

  ipcMain.on("menu-click", (event, menuId) => {
    const menu = Menu.getApplicationMenu();
    if (!menu) return;

    menu.items.forEach((item, index) => {
      if (`menu-${index}` === menuId && item.click) {
        item.click(); // Execute the menu click function
      }
      if (item.submenu) {
        item.submenu.items.forEach((sub, subIndex) => {
          if (`menu-${index}-sub-${subIndex}` === menuId && sub.click) {
            sub.click();
          }
        });
      }
    });
  });

  mainWindow.maximize();

  // @ts-ignore
  store.get(SELECTED_FOLDER_STORE_NAME);

  try {
    // @ts-ignore
    cwd = store.get(SELECTED_FOLDER_STORE_NAME).root;
  } catch {
    cwd = "/";
  }

  Pty({ cwd: cwd, ipcMain: ipcMain });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  ipcMain.handle("open-folder", async (event, data) => {
    open_folder();
  });

  mainWindow.once("ready-to-show", () => {
    // Open the DevTools.
    mainWindow.webContents.openDevTools();
    mainWindow.show(); // Show the main window
  });
};

const createToolsWindow = () => {
  if (!toolsWindow) {
    toolsWindow = new BrowserWindow({
      height: 800,
      width: 1200,
      show: false,
      icon: path.join(__dirname, "src", "assets", "icon.ico"),
      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        // nodeIntegration: true,
      },
    });

    toolsWindow.loadURL(TOOLS_WINDOW_WEBPACK_ENTRY);

    toolsWindow.setMenuBarVisibility(false);

    toolsWindow.on("closed", () => {
      toolsWindow = null;
      mainWindow.webContents.send("tools-window-closed");
    });
  }
};

ipcMain.handle("show-tools", () => {
  createToolsWindow();

  if (toolsWindow && toolsWindow.isMinimized()) {
    toolsWindow.restore();
  }

  toolsWindow?.show();
});

ipcMain.handle("hide-tools", () => {
  if (toolsWindow) {
    toolsWindow.hide();
  }
});

const createDataStudioWindow = () => {
  if (!dataStudio) {
    dataStudio = new BrowserWindow({
      height: 800,
      width: 1200,
      show: false,
      frame: false,

      webPreferences: {
        preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
        // nodeIntegration: true,
      },
    });

    dataStudio.loadFile("./src/dataStudio.html");

    dataStudio.setMenuBarVisibility(false);

    dataStudio.on("closed", () => {
      dataStudio = null;
      mainWindow.webContents.send("datastudio-window-closed");
    });
  }
};

ipcMain.handle("show-datastudio", () => {
  createDataStudioWindow();

  if (dataStudio && dataStudio.isMinimized()) {
    dataStudio.restore();
  }

  dataStudio?.show();
});

ipcMain.handle("hide-datastudio", () => {
  if (dataStudio) {
    dataStudio.hide();
  }
});

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.whenReady().then(() => {
  createWindow();
  createToolsWindow();

  // Check for updates on startup
  autoUpdater.checkForUpdates();

  autoUpdater.on("update-available", () => {
    dialog.showMessageBox({
      type: "info",
      title: "Update Available",
      message:
        "A new version of the Anantam is available. The update will be downloaded and installed automatically.",
    });
  });

  autoUpdater.on("update-downloaded", () => {
    dialog
      .showMessageBox({
        type: "question",
        title: "Update Ready",
        message:
          "The update has been downloaded. Do you want to restart Anantam now to apply the update?",
        buttons: ["Restart Now", "Later"],
        defaultId: 0,
        cancelId: 1,
      })
      .then((result) => {
        if (result.response === 0) {
          autoUpdater.quitAndInstall();
        } else {
        }
      });
  });

  autoUpdater.on("error", (error) => {
    console.error("Update error:", error);
  });
});
// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
